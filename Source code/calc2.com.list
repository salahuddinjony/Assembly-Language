EMU8086 GENERATED LISTING. MACHINE CODE <- SOURCE.
 
calc2.com -- emu8086 assembler version: 4.08  
 
[ 4/2/2019  --  11:23:31 AM ] 
 
===================================================================================================
[LINE]     LOC: MACHINE CODE                          SOURCE
===================================================================================================
 
[   1]        :                                       
[   2]        :                                       name "calc2"
[   3]        :                                       
[   4]        :                                       ; command prompt based simple calculator (+,-,*,/) for 8086.
[   5]        :                                       ; example of calculation:
[   6]        :                                       ; input 1 <- number:   10
[   7]        :                                       ; input 2 <- operator: -
[   8]        :                                       ; input 3 <- number:   5
[   9]        :                                       ; -------------------
[  10]        :                                       ;     10 - 5 = 5
[  11]        :                                       ; output  -> number:   5
[  12]        :                                       
[  13]        :                                       
[  14]        :                                       
[  15]        :                                       
[  16]        :                                       
[  17]        :                                       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[  18]        :                                       ;;; this maro is copied from emu8086.inc ;;;
[  19]        :                                       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[  20]        :                                       ; this macro prints a char in AL and advances
[  21]        :                                       ; the current cursor position:
[  22]        :                                       PUTC    MACRO   char
[  23]        :                                       PUSH    AX
[  24]        :                                       MOV     AL, char
[  25]        :                                       MOV     AH, 0Eh
[  26]        :                                       INT     10h
[  27]        :                                       POP     AX
[  28]        :                                       ENDM
[  29]        :                                       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[  30]        :                                       
[  31]        :                                       
[  32]        :                                       
[  33]        :                                       
[  34]        :                                       
[  35]        :                                       org 100h
[  36]        :                                       
[  37]    0100: E9 71 01                              jmp start
[  38]        :                                       
[  39]        :                                       
[  40]        :                                       ; define variables:
[  41]        :                                       
[  42]    0103: 6E 6F 74 65 3A 20 63 61 6C 63 75 6C   msg0 db "note: calculator works with integer values only.",0Dh,0Ah
                61 74 6F 72 20 77 6F 72 6B 73 20 77 
                69 74 68 20 69 6E 74 65 67 65 72 20 
                76 61 6C 75 65 73 20 6F 6E 6C 79 2E 
                0D 0A                               
[  43]    0135: 74 6F 20 6C 65 61 72 6E 20 68 6F 77   db "to learn how to output the result of a float division see float.asm in examples",0Dh,0Ah,'$'
                20 74 6F 20 6F 75 74 70 75 74 20 74 
                68 65 20 72 65 73 75 6C 74 20 6F 66 
                20 61 20 66 6C 6F 61 74 20 64 69 76 
                69 73 69 6F 6E 20 73 65 65 20 66 6C 
                6F 61 74 2E 61 73 6D 20 69 6E 20 65 
                78 61 6D 70 6C 65 73 0D 0A 24       
[  44]    0187: 0D 0A 0D 0A 65 6E 74 65 72 20 66 69   msg1 db 0Dh,0Ah, 0Dh,0Ah, 'enter first number: $'
                72 73 74 20 6E 75 6D 62 65 72 3A 20 
                24                                  
[  45]    01A0: 65 6E 74 65 72 20 74 68 65 20 6F 70   msg2 db "enter the operator:    +  -  *  /     : $"
                65 72 61 74 6F 72 3A 20 20 20 20 2B 
                20 20 2D 20 20 2A 20 20 2F 20 20 20 
                20 3A 20 24                         
[  46]    01C8: 65 6E 74 65 72 20 73 65 63 6F 6E 64   msg3 db "enter second number: $"
                20 6E 75 6D 62 65 72 3A 20 24       
[  47]    01DE: 0D 0A 74 68 65 20 61 70 70 72 6F 78   msg4 db  0dh,0ah , 'the approximate result of my calculations is : $'
                69 6D 61 74 65 20 72 65 73 75 6C 74 
                20 6F 66 20 6D 79 20 63 61 6C 63 75 
                6C 61 74 69 6F 6E 73 20 69 73 3A 20 
                24                                  
[  48]    020F: 0D 0A 74 68 61 6E 6B 20 79 6F 75 20   msg5 db  0dh,0ah ,'thank you for using the calculator! press any key... ', 0Dh,0Ah, '$'
                66 6F 72 20 75 73 69 6E 67 20 74 68 
                65 20 63 61 6C 63 75 6C 61 74 6F 72 
                21 20 70 72 65 73 73 20 61 6E 79 20 
                6B 65 79 2E 2E 2E 20 0D 0A 24       
[  49]    0249: 77 72 6F 6E 67 20 6F 70 65 72 61 74   err1 db  "wrong operator!", 0Dh,0Ah , '$'
                6F 72 21 0D 0A 24                   
[  50]    025B: 20 61 6E 64 20 73 6F 6D 65 74 68 69   smth db  " and something.... $"
                6E 67 2E 2E 2E 2E 20 24             
[  51]        :                                       
[  52]        :                                       ; operator can be: '+','-','*','/' or 'q' to exit in the middle.
[  53]    026F: 3F                                    opr db '?'
[  54]        :                                       
[  55]        :                                       ; first and second number:
[  56]    0270: 00 00                                 num1 dw ?
[  57]    0272: 00 00                                 num2 dw ?
[  58]        :                                       
[  59]        :                                       
[  60]    0274:                                       start:
[  61]    0274: BA 03 01                              mov dx, offset msg0
[  62]    0277: B4 09                                 mov ah, 9
[  63]    0279: CD 21                                 int 21h
[  64]        :                                       
[  65]        :                                       
[  66]    027B: BA 87 01                              lea dx, msg1
[  67]    027E: B4 09                                 mov ah, 09h    ; output string at ds:dx
[  68]    0280: CD 21                                 int 21h
[  69]        :                                       
[  70]        :                                       
[  71]        :                                       ; get the multi-digit signed number
[  72]        :                                       ; from the keyboard, and store
[  73]        :                                       ; the result in cx register:
[  74]        :                                       
[  75]    0282: E8 CF 00                              call scan_num
[  76]        :                                       
[  77]        :                                       ; store first number:
[  78]    0285: 89 0E 70 02                           mov num1, cx
[  79]        :                                       
[  80]        :                                       
[  81]        :                                       
[  82]        :                                       ; new line:
[  83]    0289: 50 B0 0D B4 0E CD 10 58               putc 0Dh
[  84]    0291: 50 B0 0A B4 0E CD 10 58               putc 0Ah
[  85]        :                                       
[  86]        :                                       
[  87]        :                                       
[  88]        :                                       
[  89]    0299: BA A0 01                              lea dx, msg2
[  90]    029C: B4 09                                 mov ah, 09h     ; output string at ds:dx
[  91]    029E: CD 21                                 int 21h
[  92]        :                                       
[  93]        :                                       
[  94]        :                                       ; get operator:
[  95]    02A0: B4 01                                 mov ah, 1   ; single char input to AL.
[  96]    02A2: CD 21                                 int 21h
[  97]    02A4: A2 6F 02                              mov opr, al
[  98]        :                                       
[  99]        :                                       
[ 100]        :                                       
[ 101]        :                                       ; new line:
[ 102]    02A7: 50 B0 0D B4 0E CD 10 58               putc 0Dh
[ 103]    02AF: 50 B0 0A B4 0E CD 10 58               putc 0Ah
[ 104]        :                                       
[ 105]        :                                       
[ 106]    02B7: 80 3E 6F 02 71                        cmp opr, 'q'      ; q - exit in the middle.
[ 107]    02BC: 74 46                                 je exit
[ 108]        :                                       
[ 109]    02BE: 80 3E 6F 02 2A                        cmp opr, '*'
[ 110]    02C3: 72 38                                 jb wrong_opr
[ 111]    02C5: 80 3E 6F 02 2F                        cmp opr, '/'
[ 112]    02CA: 77 31                                 ja wrong_opr
[ 113]        :                                       
[ 114]        :                                       
[ 115]        :                                       
[ 116]        :                                       
[ 117]        :                                       
[ 118]        :                                       
[ 119]        :                                       ; output of a string at ds:dx
[ 120]    02CC: BA C8 01                              lea dx, msg3
[ 121]    02CF: B4 09                                 mov ah, 09h
[ 122]    02D1: CD 21                                 int 21h
[ 123]        :                                       
[ 124]        :                                       
[ 125]        :                                       ; get the multi-digit signed number
[ 126]        :                                       ; from the keyboard, and store
[ 127]        :                                       ; the result in cx register:
[ 128]        :                                       
[ 129]    02D3: E8 7E 00                              call scan_num
[ 130]        :                                       
[ 131]        :                                       
[ 132]        :                                       ; store second number:
[ 133]    02D6: 89 0E 72 02                           mov num2, cx
[ 134]        :                                       
[ 135]        :                                       
[ 136]        :                                       
[ 137]        :                                       
[ 138]    02DA: BA DE 01                              lea dx, msg4
[ 139]    02DD: B4 09                                 mov ah, 09h      ; output string at ds:dx
[ 140]    02DF: CD 21                                 int 21h
[ 141]        :                                       
[ 142]        :                                       
[ 143]        :                                       
[ 144]        :                                       
[ 145]        :                                       ; calculate:
[ 146]        :                                       
[ 147]        :                                       
[ 148]        :                                       
[ 149]        :                                       
[ 150]        :                                       
[ 151]    02E1: 80 3E 6F 02 2B                        cmp opr, '+'
[ 152]    02E6: 74 28                                 je do_plus
[ 153]        :                                       
[ 154]    02E8: 80 3E 6F 02 2D                        cmp opr, '-'
[ 155]    02ED: 74 2D                                 je do_minus
[ 156]        :                                       
[ 157]    02EF: 80 3E 6F 02 2A                        cmp opr, '*'
[ 158]    02F4: 74 32                                 je do_mult
[ 159]        :                                       
[ 160]    02F6: 80 3E 6F 02 2F                        cmp opr, '/'
[ 161]    02FB: 74 37                                 je do_div
[ 162]        :                                       
[ 163]        :                                       
[ 164]        :                                       ; none of the above....
[ 165]    02FD:                                       wrong_opr:
[ 166]    02FD: BA 49 02                              lea dx, err1
[ 167]    0300: B4 09                                 mov ah, 09h     ; output string at ds:dx
[ 168]    0302: CD 21                                 int 21h
[ 169]        :                                       
[ 170]        :                                       
[ 171]    0304:                                       exit:
[ 172]        :                                       ; output of a string at ds:dx
[ 173]    0304: BA 0F 02                              lea dx, msg5
[ 174]    0307: B4 09                                 mov ah, 09h
[ 175]    0309: CD 21                                 int 21h
[ 176]        :                                       
[ 177]        :                                       
[ 178]        :                                       ; wait for any key...
[ 179]    030B: B4 00                                 mov ah, 0
[ 180]    030D: CD 16                                 int 16h
[ 181]        :                                       
[ 182]        :                                       
[ 183]    030F: C3                                    ret  ; return back to os.
[ 184]        :                                       
[ 185]        :                                       
[ 186]        :                                       
[ 187]        :                                       
[ 188]        :                                       
[ 189]        :                                       
[ 190]        :                                       
[ 191]        :                                       
[ 192]        :                                       
[ 193]        :                                       
[ 194]        :                                       
[ 195]    0310:                                       do_plus:
[ 196]        :                                       
[ 197]        :                                       
[ 198]    0310: A1 70 02                              mov ax, num1
[ 199]    0313: 03 06 72 02                           add ax, num2
[ 200]    0317: E8 FB 00                              call print_num    ; print ax value.
[ 201]        :                                       
[ 202]    031A: EB E8                                 jmp exit
[ 203]        :                                       
[ 204]        :                                       
[ 205]        :                                       
[ 206]    031C:                                       do_minus:
[ 207]        :                                       
[ 208]    031C: A1 70 02                              mov ax, num1
[ 209]    031F: 2B 06 72 02                           sub ax, num2
[ 210]    0323: E8 EF 00                              call print_num    ; print ax value.
[ 211]        :                                       
[ 212]    0326: EB DC                                 jmp exit
[ 213]        :                                       
[ 214]        :                                       
[ 215]        :                                       
[ 216]        :                                       
[ 217]    0328:                                       do_mult:
[ 218]        :                                       
[ 219]    0328: A1 70 02                              mov ax, num1
[ 220]    032B: F7 2E 72 02                           imul num2 ; (dx ax) = ax * num2.
[ 221]    032F: E8 E3 00                              call print_num    ; print ax value.
[ 222]        :                                       ; dx is ignored (calc works with tiny numbers only).
[ 223]        :                                       
[ 224]    0332: EB D0                                 jmp exit
[ 225]        :                                       
[ 226]        :                                       
[ 227]        :                                       
[ 228]        :                                       
[ 229]    0334:                                       do_div:
[ 230]        :                                       ; dx is ignored (calc works with tiny integer numbers only).
[ 231]    0334: BA 00 00                              mov dx, 0
[ 232]    0337: A1 70 02                              mov ax, num1
[ 233]    033A: F7 3E 72 02                           idiv num2  ; ax = (dx ax) / num2.
[ 234]    033E: 83 FA 00                              cmp dx, 0
[ 235]    0341: 75 05                                 jnz approx
[ 236]    0343: E8 CF 00                              call print_num    ; print ax value.
[ 237]    0346: EB BC                                 jmp exit
[ 238]    0348:                                       approx:
[ 239]    0348: E8 CA 00                              call print_num    ; print ax value.
[ 240]    034B: BA 5B 02                              lea dx, smth
[ 241]    034E: B4 09                                 mov ah, 09h    ; output string at ds:dx
[ 242]    0350: CD 21                                 int 21h
[ 243]    0352: EB B0                                 jmp exit
[ 244]        :                                       
[ 245]        :                                       
[ 246]        :                                       
[ 247]        :                                       
[ 248]        :                                       
[ 249]        :                                       
[ 250]        :                                       
[ 251]        :                                       
[ 252]        :                                       
[ 253]        :                                       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[ 254]        :                                       ;;; these functions are copied from emu8086.inc ;;;
[ 255]        :                                       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[ 256]        :                                       
[ 257]        :                                       
[ 258]        :                                       ; gets the multi-digit SIGNED number from the keyboard,
[ 259]        :                                       ; and stores the result in CX register:
[ 260]    0354:                                       SCAN_NUM        PROC    NEAR
[ 261]    0354: 52                                    PUSH    DX
[ 262]    0355: 50                                    PUSH    AX
[ 263]    0356: 56                                    PUSH    SI
[ 264]        :                                       
[ 265]    0357: B9 00 00                              MOV     CX, 0
[ 266]        :                                       
[ 267]        :                                       ; reset flag:
[ 268]    035A: 2E C6 06 14 04 00                     MOV     CS:make_minus, 0
[ 269]        :                                       
[ 270]    0360:                                       next_digit:
[ 271]        :                                       
[ 272]        :                                       ; get char from keyboard
[ 273]        :                                       ; into AL:
[ 274]    0360: B4 00                                 MOV     AH, 00h
[ 275]    0362: CD 16                                 INT     16h
[ 276]        :                                       ; and print it:
[ 277]    0364: B4 0E                                 MOV     AH, 0Eh
[ 278]    0366: CD 10                                 INT     10h
[ 279]        :                                       
[ 280]        :                                       ; check for MINUS:
[ 281]    0368: 3C 2D                                 CMP     AL, '-'
[ 282]    036A: 74 69                                 JE      set_minus
[ 283]        :                                       
[ 284]        :                                       ; check for ENTER key:
[ 285]    036C: 3C 0D                                 CMP     AL, 0Dh  ; carriage return?
[ 286]    036E: 75 03                                 JNE     not_cr
[ 287]    0370: E9 93 00                              JMP     stop_input
[ 288]    0373:                                       not_cr:
[ 289]        :                                       
[ 290]        :                                       
[ 291]    0373: 3C 08                                 CMP     AL, 8                   ; 'BACKSPACE' pressed?
[ 292]    0375: 75 1E                                 JNE     backspace_checked
[ 293]    0377: BA 00 00                              MOV     DX, 0                   ; remove last digit by
[ 294]    037A: 8B C1                                 MOV     AX, CX                  ; division:
[ 295]    037C: 2E F7 36 89 04                        DIV     CS:ten                  ; AX = DX:AX / 10 (DX-rem).
[ 296]    0381: 8B C8                                 MOV     CX, AX
[ 297]    0383: 50 B0 20 B4 0E CD 10 58               PUTC    ' '                     ; clear position.
[ 298]    038B: 50 B0 08 B4 0E CD 10 58               PUTC    8                       ; backspace again.
[ 299]    0393: EB CB                                 JMP     next_digit
[ 300]    0395:                                       backspace_checked:
[ 301]        :                                       
[ 302]        :                                       
[ 303]        :                                       ; allow only digits:
[ 304]    0395: 3C 30                                 CMP     AL, '0'
[ 305]    0397: 73 02                                 JAE     ok_AE_0
[ 306]    0399: EB 04                                 JMP     remove_not_digit
[ 307]    039B:                                       ok_AE_0:
[ 308]    039B: 3C 39                                 CMP     AL, '9'
[ 309]    039D: 76 1A                                 JBE     ok_digit
[ 310]    039F:                                       remove_not_digit:
[ 311]    039F: 50 B0 08 B4 0E CD 10 58               PUTC    8       ; backspace.
[ 312]    03A7: 50 B0 20 B4 0E CD 10 58               PUTC    ' '     ; clear last entered not digit.
[ 313]    03AF: 50 B0 08 B4 0E CD 10 58               PUTC    8       ; backspace again.
[ 314]    03B7: EB A7                                 JMP     next_digit ; wait for next input.
[ 315]    03B9:                                       ok_digit:
[ 316]        :                                       
[ 317]        :                                       
[ 318]        :                                       ; multiply CX by 10 (first time the result is zero)
[ 319]    03B9: 50                                    PUSH    AX
[ 320]    03BA: 8B C1                                 MOV     AX, CX
[ 321]    03BC: 2E F7 26 89 04                        MUL     CS:ten                  ; DX:AX = AX*10
[ 322]    03C1: 8B C8                                 MOV     CX, AX
[ 323]    03C3: 58                                    POP     AX
[ 324]        :                                       
[ 325]        :                                       ; check if the number is too big
[ 326]        :                                       ; (result should be 16 bits)
[ 327]    03C4: 83 FA 00                              CMP     DX, 0
[ 328]    03C7: 75 19                                 JNE     too_big
[ 329]        :                                       
[ 330]        :                                       ; convert from ASCII code:
[ 331]    03C9: 2C 30                                 SUB     AL, 30h
[ 332]        :                                       
[ 333]        :                                       ; add AL to CX:
[ 334]    03CB: B4 00                                 MOV     AH, 0
[ 335]    03CD: 8B D1                                 MOV     DX, CX      ; backup, in case the result will be too big.
[ 336]    03CF: 03 C8                                 ADD     CX, AX
[ 337]    03D1: 72 0A                                 JC      too_big2    ; jump if the number is too big.
[ 338]        :                                       
[ 339]    03D3: EB 8B                                 JMP     next_digit
[ 340]        :                                       
[ 341]    03D5:                                       set_minus:
[ 342]    03D5: 2E C6 06 14 04 01                     MOV     CS:make_minus, 1
[ 343]    03DB: EB 83                                 JMP     next_digit
[ 344]        :                                       
[ 345]    03DD:                                       too_big2:
[ 346]    03DD: 8B CA                                 MOV     CX, DX      ; restore the backuped value before add.
[ 347]    03DF: BA 00 00                              MOV     DX, 0       ; DX was zero before backup!
[ 348]    03E2:                                       too_big:
[ 349]    03E2: 8B C1                                 MOV     AX, CX
[ 350]    03E4: 2E F7 36 89 04                        DIV     CS:ten  ; reverse last DX:AX = AX*10, make AX = DX:AX / 10
[ 351]    03E9: 8B C8                                 MOV     CX, AX
[ 352]    03EB: 50 B0 08 B4 0E CD 10 58               PUTC    8       ; backspace.
[ 353]    03F3: 50 B0 20 B4 0E CD 10 58               PUTC    ' '     ; clear last entered digit.
[ 354]    03FB: 50 B0 08 B4 0E CD 10 58               PUTC    8       ; backspace again.
[ 355]    0403: E9 5A FF                              JMP     next_digit ; wait for Enter/Backspace.
[ 356]        :                                       
[ 357]        :                                       
[ 358]    0406:                                       stop_input:
[ 359]        :                                       ; check flag:
[ 360]    0406: 2E 80 3E 14 04 00                     CMP     CS:make_minus, 0
[ 361]    040C: 74 02                                 JE      not_minus
[ 362]    040E: F7 D9                                 NEG     CX
[ 363]    0410:                                       not_minus:
[ 364]        :                                       
[ 365]    0410: 5E                                    POP     SI
[ 366]    0411: 58                                    POP     AX
[ 367]    0412: 5A                                    POP     DX
[ 368]    0413: C3                                    RET
[ 369]    0414: 00                                    make_minus      DB      ?       ; used as a flag.
[ 370]        :                                       SCAN_NUM        ENDP
[ 371]        :                                       
[ 372]        :                                       
[ 373]        :                                       
[ 374]        :                                       
[ 375]        :                                       
[ 376]        :                                       ; this procedure prints number in AX,
[ 377]        :                                       ; used with PRINT_NUM_UNS to print signed numbers:
[ 378]    0415:                                       PRINT_NUM       PROC    NEAR
[ 379]    0415: 52                                    PUSH    DX
[ 380]    0416: 50                                    PUSH    AX
[ 381]        :                                       
[ 382]    0417: 3D 00 00                              CMP     AX, 0
[ 383]    041A: 75 0A                                 JNZ     not_zero
[ 384]        :                                       
[ 385]    041C: 50 B0 30 B4 0E CD 10 58               PUTC    '0'
[ 386]    0424: EB 12                                 JMP     printed
[ 387]        :                                       
[ 388]    0426:                                       not_zero:
[ 389]        :                                       ; the check SIGN of AX,
[ 390]        :                                       ; make absolute if it's negative:
[ 391]    0426: 3D 00 00                              CMP     AX, 0
[ 392]    0429: 79 0A                                 JNS     positive
[ 393]    042B: F7 D8                                 NEG     AX
[ 394]        :                                       
[ 395]    042D: 50 B0 2D B4 0E CD 10 58               PUTC    '-'
[ 396]        :                                       
[ 397]    0435:                                       positive:
[ 398]    0435: E8 03 00                              CALL    PRINT_NUM_UNS
[ 399]    0438:                                       printed:
[ 400]    0438: 58                                    POP     AX
[ 401]    0439: 5A                                    POP     DX
[ 402]    043A: C3                                    RET
[ 403]        :                                       PRINT_NUM       ENDP
[ 404]        :                                       
[ 405]        :                                       
[ 406]        :                                       
[ 407]        :                                       ; this procedure prints out an unsigned
[ 408]        :                                       ; number in AX (not just a single digit)
[ 409]        :                                       ; allowed values are from 0 to 65535 (FFFF)
[ 410]    043B:                                       PRINT_NUM_UNS   PROC    NEAR
[ 411]    043B: 50                                    PUSH    AX
[ 412]    043C: 53                                    PUSH    BX
[ 413]    043D: 51                                    PUSH    CX
[ 414]    043E: 52                                    PUSH    DX
[ 415]        :                                       
[ 416]        :                                       ; flag to prevent printing zeros before number:
[ 417]    043F: B9 01 00                              MOV     CX, 1
[ 418]        :                                       
[ 419]        :                                       ; (result of "/ 10000" is always less or equal to 9).
[ 420]    0442: BB 10 27                              MOV     BX, 10000       ; 2710h - divider.
[ 421]        :                                       
[ 422]        :                                       ; AX is zero?
[ 423]    0445: 3D 00 00                              CMP     AX, 0
[ 424]    0448: 74 32                                 JZ      print_zero
[ 425]        :                                       
[ 426]    044A:                                       begin_print:
[ 427]        :                                       
[ 428]        :                                       ; check divider (if zero go to end_print):
[ 429]    044A: 83 FB 00                              CMP     BX,0
[ 430]    044D: 74 35                                 JZ      end_print
[ 431]        :                                       
[ 432]        :                                       ; avoid printing zeros before number:
[ 433]    044F: 83 F9 00                              CMP     CX, 0
[ 434]    0452: 74 04                                 JE      calc
[ 435]        :                                       ; if AX<BX then result of DIV will be zero:
[ 436]    0454: 3B C3                                 CMP     AX, BX
[ 437]    0456: 72 14                                 JB      skip
[ 438]    0458:                                       calc:
[ 439]    0458: B9 00 00                              MOV     CX, 0   ; set flag.
[ 440]        :                                       
[ 441]    045B: BA 00 00                              MOV     DX, 0
[ 442]    045E: F7 F3                                 DIV     BX      ; AX = DX:AX / BX   (DX=remainder).
[ 443]        :                                       
[ 444]        :                                       ; print last digit
[ 445]        :                                       ; AH is always ZERO, so it's ignored
[ 446]    0460: 04 30                                 ADD     AL, 30h    ; convert to ASCII code.
[ 447]    0462: 50 8A C0 B4 0E CD 10 58               PUTC    AL
[ 448]        :                                       
[ 449]        :                                       
[ 450]    046A: 8B C2                                 MOV     AX, DX  ; get remainder from last div.
[ 451]        :                                       
[ 452]    046C:                                       skip:
[ 453]        :                                       ; calculate BX=BX/10
[ 454]    046C: 50                                    PUSH    AX
[ 455]    046D: BA 00 00                              MOV     DX, 0
[ 456]    0470: 8B C3                                 MOV     AX, BX
[ 457]    0472: 2E F7 36 89 04                        DIV     CS:ten  ; AX = DX:AX / 10   (DX=remainder).
[ 458]    0477: 8B D8                                 MOV     BX, AX
[ 459]    0479: 58                                    POP     AX
[ 460]        :                                       
[ 461]    047A: EB CE                                 JMP     begin_print
[ 462]        :                                       
[ 463]    047C:                                       print_zero:
[ 464]    047C: 50 B0 30 B4 0E CD 10 58               PUTC    '0'
[ 465]        :                                       
[ 466]    0484:                                       end_print:
[ 467]        :                                       
[ 468]    0484: 5A                                    POP     DX
[ 469]    0485: 59                                    POP     CX
[ 470]    0486: 5B                                    POP     BX
[ 471]    0487: 58                                    POP     AX
[ 472]    0488: C3                                    RET
[ 473]        :                                       PRINT_NUM_UNS   ENDP
[ 474]        :                                       
[ 475]        :                                       
[ 476]        :                                       
[ 477]    0489: 0A 00                                 ten             DW      10      ; used as multiplier/divider by SCAN_NUM & PRINT_NUM_UNS.
[ 478]        :                                       
[ 479]        :                                       
[ 480]        :                                       
[ 481]        :                                       
[ 482]        :                                       
[ 483]        :                                       
[ 484]        :                                       
[ 485]    048B:                                       GET_STRING      PROC    NEAR
[ 486]    048B: 50                                    PUSH    AX
[ 487]    048C: 51                                    PUSH    CX
[ 488]    048D: 57                                    PUSH    DI
[ 489]    048E: 52                                    PUSH    DX
[ 490]        :                                       
[ 491]    048F: B9 00 00                              MOV     CX, 0                   ; char counter.
[ 492]        :                                       
[ 493]    0492: 83 FA 01                              CMP     DX, 1                   ; buffer too small?
[ 494]    0495: 76 3C                                 JBE     empty_buffer            ;
[ 495]        :                                       
[ 496]    0497: 4A                                    DEC     DX                      ; reserve space for last zero.
[ 497]        :                                       
[ 498]        :                                       
[ 499]        :                                       ;============================
[ 500]        :                                       ; Eternal loop to get
[ 501]        :                                       ; and processes key presses:
[ 502]        :                                       
[ 503]    0498:                                       wait_for_key:
[ 504]        :                                       
[ 505]    0498: B4 00                                 MOV     AH, 0                   ; get pressed key.
[ 506]    049A: CD 16                                 INT     16h
[ 507]        :                                       
[ 508]    049C: 3C 0D                                 CMP     AL, 0Dh                  ; 'RETURN' pressed?
[ 509]    049E: 74 30                                 JZ      exit_GET_STRING
[ 510]        :                                       
[ 511]        :                                       
[ 512]    04A0: 3C 08                                 CMP     AL, 8                   ; 'BACKSPACE' pressed?
[ 513]    04A2: 75 1E                                 JNE     add_to_buffer
[ 514]    04A4: E3 F2                                 JCXZ    wait_for_key            ; nothing to remove!
[ 515]    04A6: 49                                    DEC     CX
[ 516]    04A7: 4F                                    DEC     DI
[ 517]    04A8: 50 B0 08 B4 0E CD 10 58               PUTC    8                       ; backspace.
[ 518]    04B0: 50 B0 20 B4 0E CD 10 58               PUTC    ' '                     ; clear position.
[ 519]    04B8: 50 B0 08 B4 0E CD 10 58               PUTC    8                       ; backspace again.
[ 520]    04C0: EB D6                                 JMP     wait_for_key
[ 521]        :                                       
[ 522]    04C2:                                       add_to_buffer:
[ 523]        :                                       
[ 524]    04C2: 3B CA                                 CMP     CX, DX          ; buffer is full?
[ 525]    04C4: 73 D2                                 JAE     wait_for_key    ; if so wait for 'BACKSPACE' or 'RETURN'...
[ 526]        :                                       
[ 527]    04C6: 88 05                                 MOV     [DI], AL
[ 528]    04C8: 47                                    INC     DI
[ 529]    04C9: 41                                    INC     CX
[ 530]        :                                       
[ 531]        :                                       ; print the key:
[ 532]    04CA: B4 0E                                 MOV     AH, 0Eh
[ 533]    04CC: CD 10                                 INT     10h
[ 534]        :                                       
[ 535]    04CE: EB C8                                 JMP     wait_for_key
[ 536]        :                                       ;============================
[ 537]        :                                       
[ 538]    04D0:                                       exit_GET_STRING:
[ 539]        :                                       
[ 540]        :                                       ; terminate by null:
[ 541]    04D0: C6 05 00                              MOV     [DI], 0
[ 542]        :                                       
[ 543]    04D3:                                       empty_buffer:
[ 544]        :                                       
[ 545]    04D3: 5A                                    POP     DX
[ 546]    04D4: 5F                                    POP     DI
[ 547]    04D5: 59                                    POP     CX
[ 548]    04D6: 58                                    POP     AX
[ 549]    04D7: C3                                    RET
[ 550]        :                                       GET_STRING      ENDP
[ 551]        :                                       
[ 552]        :                                       
[ 553]        :                                       
[ 554]        :                                       
[ 555]        :                                       
 
===================================================================================================
 




===================================================================================================
